
git show
git reset –hard
git push origin HEAD
git switch -c fix_error
git switch main
git merge hotfix
git branch -d hotfix
git push origin branch1
git push origin –delete hotfix

git mv cp rm -r

git diff master feature # посмотреть что сделано в ветке feature по 
сравнению с веткой master
git diff --name-only master feature # посмотреть что сделано в ветке 
feature по сравнению с веткой master, показать только имена файлов
git diff master...feature # посмотреть что сделано в ветке feature 
с момента (коммита) расхождения с master

git reset            # убрать из индекса все добавленные в него изменения 
(в рабочей директории все изменения сохранятся), антипод git add
git reset readme.txt # убрать из индекса изменения указанного файла 
(в рабочей директории изменения сохранятся)

git clean -df              # удалить неотслеживаемые файлы и директории

git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения 
последнего коммита без запуска редактора сообщения
git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые 
коммитом с указанным хешем (b9533bb)

Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были 
отправлены в удалённый репозиторий.
# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, 
заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, 
сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными 
из «отменяемого» коммита, но новым сообщением)
git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, 
рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным 
хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита
git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, 
но в рабочей директории и индексе оставить все изменения
git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад
git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, 
рабочую директорию оставить как есть, индекс сделать таким, каким он был в 
момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)
# Почти как git reset --hard, но безопаснее: не получится потерять 
изменения в рабочей директории
git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, 
сбросить индекс, но в рабочей директории оставить изменения, если возможно 
(если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)

git checkout 5589877 index.html  # восстановить в рабочей директории 
указанный файл на момент указанного коммита (и добавить это изменение в индекс) 
(git reset index.html для удаления из индекса, но сохранения изменений в файле)

Копирование коммита (перенос коммитов)
git cherry-pick 5589877          # скопировать на активную ветку изменения 
из указанного коммита, закоммитить эти изменения
git cherry-pick master~2..master # скопировать на активную ветку изменения 
из master (2 последних коммита)
git cherry-pick -n 5589877       # скопировать на активную ветку изменения 
из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
git cherry-pick master..feature  # скопировать на активную ветку изменения 
из всех коммитов ветки feature с момента её расхождения с master (похоже на 
слияние веток, но это копирование изменений, а не слияние), закоммитить эти 
изменения; это может вызвать конфликт
git cherry-pick --abort    # прервать конфликтный перенос коммитов
git cherry-pick --continue # продолжить конфликтный перенос коммитов 
(сработает только после решения конфликта)

git rm text.txt    # удалить отслеживаемый неизменённый файл и проиндексировать это изменение
git rm -f text.txt # удалить отслеживаемый изменённый файл и проиндексировать это изменение
git rm -r log/     # удалить всё содержимое отслеживаемой директории log/ и 
проиндексировать это изменение
git rm ind*        # удалить все отслеживаемые файлы с именем, начинающимся 
на «ind» в текущей директории и проиндексировать это изменение
git rm --cached readme.txt # удалить из отслеживаемых индексированный файл 
(ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)

# Перемещение/переименование файлов
Для git не существует переименования. Переименование воспринимается 
как удаление старого файла и создание нового. Факт переименования 
может быть определен только после индексации изменения.
git mv file1 file2 # .. и проиндексировать это изменение
git mv readme_new.md folder/ # переместить файл и проиндексировать это изменение

# История коммитов
git log --since=2.weeks    # показать коммиты за последние 2 недели
git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты
git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction 
(в кавычках регулярное выражение)
git log -L '/head/','/\/head/':index.html # показать изменения от указанного до 
указанного регулярных выражений в указанном файле

git log master..branch_99  # показать коммиты из ветки branch_99, 
которые не влиты в master
git log branch_99..master  # показать коммиты из ветки master, 
которые не влиты в branch_99
git log master...branch_99 --boundary -- graph # показать коммиты 
из указанных веток, начиная с их расхождения (коммит расхождения будет показан)

git show 60d6582           # показать изменения из коммита с указанным хешем
git show HEAD~             # показать данные о предыдущем коммите в активной ветке
git show @~                # аналогично предыдущему
git show HEAD~3            # показать данные о коммите, который был 3 коммита назад
git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке
git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита
git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)

git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены

История изменений указателей (веток, HEAD)
git reflog -20             # показать последние 20 изменений положения указателя HEAD
git reflog --format='%C(auto)%h %|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий

Есть два распространённых способа привязать удалённый репозиторий к локальному: 
по HTTPS и по SSH. Если SSH у вас не настроен (или вы не знаете что это), 
привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).
git remote -v              # показать список удалённых репозиториев, связанных с локальным
git branch -r              # показать удаленные ветки
git branch -a              # показать все ветки(локальные и удаленные)       
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий 
с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), 
но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch 
(данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)

# Конфликт слияния
Предполагается ситуация: есть ветка master и есть ветка feature. В обеих ветках есть коммиты, 
сделанные после расхождения веток. В ветку master пытаемся влить ветку feature (git merge feature), 
получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле index.html.
При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. 
Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.
git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, 
В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, 
ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение 
содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) 
сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки

«Перенос» ветки
Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. 
Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, 
внесённые в основной ветке (уже после ответвления переносимой).
Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.
git rebase master # перенести все коммиты (создать их копии) активной ветки так, 
будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)
git rebase --onto master feature # перенести коммиты активной ветки на master, 
начиная с того места, в котором активная ветка отделилась от ветки feature
git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и 
индекс к состоянию до начала rebase
git rebase --continue # продолжить конфликтный rebase (сработает только после 
разрешения конфликта и индексации такого разрешения)

# Отменить пребазирование
git reflog feature -2  # смотрим лог перемещений ветки, которой делали rebase 
(в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки
git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, 
обновить рабочую директорию и индекс

git archive -o ./project.zip HEAD # создать архив с файловой структурой 
проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)
